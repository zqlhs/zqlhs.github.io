<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>藏书阁</title>
  <icon>https://www.gravatar.com/avatar/f891a51eb4e19375142db2543d2003e2</icon>
  <subtitle>奔跑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuhusen.com/"/>
  <updated>2019-01-18T07:06:06.361Z</updated>
  <id>https://liuhusen.com/</id>
  
  <author>
    <name>Mr.Liu</name>
    <email>I_striving@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的扒拉后台日志操作命令</title>
    <link href="https://liuhusen.com/2018/08/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%92%E6%8B%89%E5%90%8E%E5%8F%B0%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>https://liuhusen.com/2018/08/08/常用的扒拉后台日志操作命令/</id>
    <published>2018-08-08T05:01:30.000Z</published>
    <updated>2019-01-18T07:06:06.361Z</updated>
    
    <content type="html"><![CDATA[<p>   翻找环境上的日志：<br>              ll                                     展示目录<br>              cd                                     进入含有日志文件的文件夹目录<br>              tail -200f 文件名                      实时查看200行日志<br>              cat 文件名 | grep “关键字” -A 页数     展示出含有关键字的后面的页数<br>              cat 文件名 | grep “关键字” -B 页数     展示出含有关键字的前面的页数<br>              cat 文件名 | grep “关键字” -C 页数     展示出含有关键字的上下文的页数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   翻找环境上的日志：&lt;br&gt;              ll                                     展示目录&lt;br&gt;              cd                                     进入含有日志文
      
    
    </summary>
    
      <category term="关于日志" scheme="https://liuhusen.com/categories/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="生产日志" scheme="https://liuhusen.com/tags/%E7%94%9F%E4%BA%A7%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>简单有效的页面防止重复提交的操作</title>
    <link href="https://liuhusen.com/2017/06/08/%E7%AE%80%E5%8D%95%E6%9C%89%E6%95%88%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://liuhusen.com/2017/06/08/简单有效的页面防止重复提交的操作/</id>
    <published>2017-06-08T05:01:30.000Z</published>
    <updated>2018-10-31T07:41:51.026Z</updated>
    
    <content type="html"><![CDATA[<pre><code>操作如下：     var isSubmit = true; // 在js顶部定义全局变量    if(isSubmit){       save();    }else{       crossAPI.tips(&quot;请勿重复提交数据！&quot;,3000);       return false;    }    var save = function () {          isSubmit = false; // 进入方法后 isSubmit 置为 false，在后续的点击提交时，便不会执行save方法          。。。          。。。 // 此处为你自己的执行保存的方法          if( 保存成功 ){             关闭数据新增页面，并刷新查询页面的查询          }else{             // 保存失败，则页面提醒保存失败             isSubmit = true;  // isSubmit 置为 true ,用以再次提交当前数据使用          }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;操作如下： 

    var isSubmit = true; // 在js顶部定义全局变量

    if(isSubmit){
       save();
    }else{
       crossAPI.tips(&amp;quot;请勿重复提交数据！
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
      <category term="防止重复提交" scheme="https://liuhusen.com/tags/%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的表以及数据备份</title>
    <link href="https://liuhusen.com/2017/05/26/MySQL%E7%9A%84%E8%A1%A8%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>https://liuhusen.com/2017/05/26/MySQL的表以及数据备份/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2018-10-28T19:14:11.519Z</updated>
    
    <content type="html"><![CDATA[<p>   备份表方法：  此方法索引和increment值也会同步</p><pre><code>CREATE TABLE tb_cab_bak LIKE tb_cab; // 同步建表INSERT INTO tb_cab_bak SELECT * FROM tb_cab；// 同步数据</code></pre><p>   若只复制表中的部分内容的同时定义表中的字段信息：<br>                 CREATE TABLE tb_cab_bak<br>                  (<br>                  – 对copy的表中的ID进行主键约束<br>                 ID INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY<br>                   )<br>                 AS<br>                 ( SELECT ID,SNAME,SCORE FROM tb_cab_bak );</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   备份表方法：  此方法索引和increment值也会同步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE tb_cab_bak LIKE tb_cab; // 同步建表

INSERT INTO tb_cab_bak SELECT * FROM tb_cab；
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="https://liuhusen.com/tags/MySQL/"/>
    
      <category term="数据备份" scheme="https://liuhusen.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>自学编程成功概率有多少可能</title>
    <link href="https://liuhusen.com/2017/05/26/%E5%85%B3%E4%BA%8E/"/>
    <id>https://liuhusen.com/2017/05/26/关于/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2018-10-25T06:24:46.244Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="档案" scheme="https://liuhusen.com/categories/%E6%A1%A3%E6%A1%88/"/>
    
    
      <category term="编程" scheme="https://liuhusen.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="感悟" scheme="https://liuhusen.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>接口传输时对乱码的处理和post与个体的区别</title>
    <link href="https://liuhusen.com/2017/05/26/%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%97%B6%E5%AF%B9%E4%B9%B1%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8Cpost%E4%B8%8E%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liuhusen.com/2017/05/26/接口传输时对乱码的处理和post与个体的区别/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2019-01-31T09:23:33.724Z</updated>
    
    <content type="html"><![CDATA[<pre><code>表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &apos;字段描述&apos;;表删除字段： ALTER TABLE 表名 DROP COLUMN  表字段 ;字段建唯一索引：create index idx_province_id on 表名 (表字段 );                               上为索引                create index 字段的索引 on 表名 (表字段 );               删除字段的索引：alter table 表名 drop index idx_province_id ;                                        上为索引                alter table 表名 drop 字段的索引 ;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &amp;apos;字段描述&amp;apos;;

表删除字段： ALTER TABLE 表名 DROP COLUMN  表字段 ;
      
    
    </summary>
    
      <category term="接口传输" scheme="https://liuhusen.com/categories/%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93/"/>
    
    
      <category term="接口传输" scheme="https://liuhusen.com/tags/%E6%8E%A5%E5%8F%A3%E4%BC%A0%E8%BE%93/"/>
    
      <category term="post请求传输" scheme="https://liuhusen.com/tags/post%E8%AF%B7%E6%B1%82%E4%BC%A0%E8%BE%93/"/>
    
      <category term="get请求传输" scheme="https://liuhusen.com/tags/get%E8%AF%B7%E6%B1%82%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的表增删字段和增删索引</title>
    <link href="https://liuhusen.com/2017/05/26/MySQL%E7%9A%84%E8%A1%A8%E5%A2%9E%E5%88%A0%E5%AD%97%E6%AE%B5%E5%92%8C%E5%A2%9E%E5%88%A0%E7%B4%A2%E5%BC%95/"/>
    <id>https://liuhusen.com/2017/05/26/MySQL的表增删字段和增删索引/</id>
    <published>2017-05-26T11:57:47.000Z</published>
    <updated>2018-10-28T19:13:31.613Z</updated>
    
    <content type="html"><![CDATA[<pre><code>表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &apos;字段描述&apos;;表删除字段： ALTER TABLE 表名 DROP COLUMN  表字段 ;字段建唯一索引：create index idx_province_id on 表名 (表字段 );                               上为索引                create index 字段的索引 on 表名 (表字段 );               删除字段的索引：alter table 表名 drop index idx_province_id ;                                        上为索引                alter table 表名 drop 字段的索引 ;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &amp;apos;字段描述&amp;apos;;

表删除字段： ALTER TABLE 表名 DROP COLUMN  表字段 ;
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="https://liuhusen.com/tags/MySQL/"/>
    
      <category term="增删字段" scheme="https://liuhusen.com/tags/%E5%A2%9E%E5%88%A0%E5%AD%97%E6%AE%B5/"/>
    
      <category term="增删索引" scheme="https://liuhusen.com/tags/%E5%A2%9E%E5%88%A0%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>页面常用的设置：显示，隐藏，只读，不可编辑，取值，置空</title>
    <link href="https://liuhusen.com/2016/11/06/%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9A%E6%98%BE%E7%A4%BA%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%8C%E5%8F%AA%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E7%BC%96%E8%BE%91%EF%BC%8C%E5%8F%96%E5%80%BC%EF%BC%8C%E7%BD%AE%E7%A9%BA/"/>
    <id>https://liuhusen.com/2016/11/06/页面常用的设置：显示，隐藏，只读，不可编辑，取值，置空/</id>
    <published>2016-11-06T04:28:30.000Z</published>
    <updated>2018-10-31T07:14:39.622Z</updated>
    
    <content type="html"><![CDATA[<pre><code>$(&quot;#id&quot;).val()   // 获取值$(&quot;#id&quot;).val(&apos;&apos;)   // 清空值$(&quot;#id&quot;).val(&apos;变量名&apos;)   // 赋值$(&quot;#id&quot;).css(&apos;display&apos;,&apos;block&apos;) // 显示选择的对象$(&quot;#id&quot;).css(&apos;display&apos;,&apos;none&apos;) // 隐藏选择的对象$(&quot;#msgIdTpl option[value=&apos;&quot;+msgIdTpl+&quot;&apos;]&quot;).attr(&quot;selected&quot;,true);  // 锁定下拉结果并是=使下拉不可编辑$(&quot;#id,#id2,#id3&quot;).attr(&quot;readonly&quot;,&quot;readonly&quot;); //多个选择设置只读属性$(&quot;#id,#id2).attr(&quot;disabled&quot;, true);  // 设置为不可用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;$(&amp;quot;#id&amp;quot;).val()   // 获取值

$(&amp;quot;#id&amp;quot;).val(&amp;apos;&amp;apos;)   // 清空值

$(&amp;quot;#id&amp;quot;).val(&amp;apos;变量名&amp;apos;)   // 赋值
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>工作中重名判断的注意事项</title>
    <link href="https://liuhusen.com/2016/10/08/%E9%87%8D%E5%90%8D%E5%88%A4%E6%96%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://liuhusen.com/2016/10/08/重名判断的注意事项/</id>
    <published>2016-10-08T05:01:30.000Z</published>
    <updated>2018-10-31T06:31:07.533Z</updated>
    
    <content type="html"><![CDATA[<p>   工作中重名判断的注意事项：</p><p>   信息记录修改页面中重名判断如下：<br>          首先定义一个js中的全局变量stillName，用于存储要修改的信息原名；<br>          修改时判断 修改后名称是否 == 修改的信息原名，若等于则不进行重名判断，不然则反之；<br>          但是这里所有的 == 判断 以及  数据的保存，都应该是“去除数据两边空格后”的结果，<br>          否则，增减一个空格，判断结果也是不重名，而页面效果可看不到空格，给客户的视觉感受就是重名</p><p>   代码如下：<br>    var stillName = “需要更改的信息原名”</p><pre><code>if(stillName != $.trim(newName) ) {    // 此处是去数据库查找是否有信息含有  修改后名称}然后，在执行修改后数据保存的方法时传值注意：一定要也去掉空格  newName = $.trim(newName);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   工作中重名判断的注意事项：&lt;/p&gt;
&lt;p&gt;   信息记录修改页面中重名判断如下：&lt;br&gt;          首先定义一个js中的全局变量stillName，用于存储要修改的信息原名；&lt;br&gt;          修改时判断 修改后名称是否 == 修改的信息原名，若等于则
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
      <category term="重名判断" scheme="https://liuhusen.com/tags/%E9%87%8D%E5%90%8D%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用VMware安装CentOS 6.4</title>
    <link href="https://liuhusen.com/2016/08/16/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85CentOS-6-4/"/>
    <id>https://liuhusen.com/2016/08/16/使用VMware安装CentOS-6-4/</id>
    <published>2016-08-16T08:22:30.000Z</published>
    <updated>2018-11-01T05:58:16.393Z</updated>
    
    <content type="html"><![CDATA[<pre><code>环境：Windows7 , VMware Workstation10, CentOS6.4为什么选择CentOS ?1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！安装步骤第1步：首先安装VMware Workstation，只需点下一步即可，安装过程略第2步：文件 → 新建虚拟机 或 直接点击 创建新的虚拟机 图标</code></pre><p><img src="/2016/08/16/使用VMware安装CentOS-6-4/01.png" alt="你想输入的替代文字"><br>    第3步：选择 典型（推荐）→ 下一步<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/02.png" alt="你想输入的替代文字"><br>    第4步：稍后安装操作系统<br><img src="/2016/08/16/使用VMware安装CentOS-6-4/03.png" alt="你想输入的替代文字"><br>    第5步：选择操作系统和版本<br><img src="/2016/08/16/使用VMware安装CentOS-6-4/04.png" alt="你想输入的替代文字"><br>    第6步：输入虚拟机名称和安装路径<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/05.png" alt="你想输入的替代文字"><br>    第7步：设置磁盘大小<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/06.png" alt="你想输入的替代文字"><br>    第8步：自定义硬件<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/07.png" alt="你想输入的替代文字"><br>    第9步：选择CentOS安装镜像文件<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/08.png" alt="你想输入的替代文字"><br>    第10步：点击完成<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/09.png" alt="你想输入的替代文字"><br>    第11步：启动虚拟机<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/10.png" alt="你想输入的替代文字"><br>    第12步：选择第一项，安装全新操作系统或升级现有操作系统<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/11.png" alt="你想输入的替代文字"><br>    第13步：Tab键进行选择，选择Skip，退出检测<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/12.png" alt="你想输入的替代文字"><br>    第14步：点击Next<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/13.png" alt="你想输入的替代文字"><br>    第15步：选择语言，这里选择的是中文简体<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/14.png" alt="你想输入的替代文字"><br>    第16步：选择键盘样式<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/15.png" alt="你想输入的替代文字"><br>    第17步：选择存储设备<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/16.png" alt="你想输入的替代文字"><br>     如果以前安装过虚拟机，会出现这个警告，选择是，忽略所有数据<br>     <img src="/2016/08/16/使用VMware安装CentOS-6-4/17.png" alt="你想输入的替代文字"><br>    第18步：输入主机名<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/18.png" alt="你想输入的替代文字"><br>    第19步：配置网络<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/19.png" alt="你想输入的替代文字"><br>    第20步：设置时区，勾选使用UTC时间<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/20.png" alt="你想输入的替代文字"><br>    第21步：输入根用户（root）的密码<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/21.png" alt="你想输入的替代文字"><br>      如果密码过于简单会出现提示，点击无论如何都使用<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/22.png" alt="你想输入的替代文字"><br>    第22步：根据此Linux具体功能，选择不同的方式<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/23.png" alt="你想输入的替代文字"><br>    第23步：选择现在自定义，自定义安装需要的软件，如桌面配置<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/24.png" alt="你想输入的替代文字"><br>      可以根据具体的情况来配置，如可安Eclipse<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/25.png" alt="你想输入的替代文字"><br>      还可以安装Java平台、Perl支持等<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/26.png" alt="你想输入的替代文字"><br>      选择语言支持<br>      <img src="/2016/08/16/使用VMware安装CentOS-6-4/27.png" alt="你想输入的替代文字"><br>    第24步：点击下一步，开始安装<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/28.png" alt="你想输入的替代文字"><br>    第25步：安装完成后，点击重新导引<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/29.png" alt="你想输入的替代文字"><br>    第26步：点击前进按钮<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/30.png" alt="你想输入的替代文字"><br>    第27步：点击是，同意许可，再点击前进按钮<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/31.png" alt="你想输入的替代文字"><br>    第28步：创建用户<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/32.png" alt="你想输入的替代文字"><br>    第29步：设置日期和时间，如果可以上网，勾选在网上同步日期和时间<br>    <img src="/2016/08/16/使用VMware安装CentOS-6-4/33.png" alt="你想输入的替代文字"><br>    最后点击前进，完成安装！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;环境：Windows7 , VMware Workstation10, CentOS6.4
为什么选择CentOS ?
1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS
2.免费： RedHa
      
    
    </summary>
    
      <category term="虚拟机VMware" scheme="https://liuhusen.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware/"/>
    
    
      <category term="虚拟机VMware安装教程" scheme="https://liuhusen.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基本的sql语句以及高级运算符和 多表查询</title>
    <link href="https://liuhusen.com/2016/07/20/%E5%9F%BA%E6%9C%AC%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>https://liuhusen.com/2016/07/20/基本的sql语句以及高级运算符和 多表查询/</id>
    <published>2016-07-20T11:57:47.000Z</published>
    <updated>2018-10-28T19:10:15.798Z</updated>
    
    <content type="html"><![CDATA[<p>选择：select * from table1 where Id=1(Id=1为条件语句，根据自己情况自定义）</p><p>插入：insert into table1(field1,field2) values(value1,value2)</p><p>删除：delete from table1 where 范围</p><p>更新：update table1 set field1=value1 where 范围</p><p>查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!</p><p>排序：select * from table1 order by field1,field2 [desc]</p><p>总数：select count * as totalcount from table1</p><p>求和：select sum(field1) as sumvalue from table1</p><p>平均：select avg(field1) as avgvalue from table1</p><p>最大：select max(field1) as maxvalue from table1</p><p>最小：select min(field1) as minvalue from table1</p><p>11、说明：几个高级查询运算词</p><p>A： UNION 运算符</p><p>UNION 运算符通过组合其他两个结果表(例如 TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时(即 UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。</p><p>B： EXCEPT 运算符</p><p>EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p><p>C： INTERSECT 运算符</p><p>INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p><p>注：使用运算词的几个查询结果行必须是一致的。</p><p>12、说明：使用外连接</p><p>A、left outer join：</p><p>左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。</p><p>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p><p>B：right outer join:</p><p>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。</p><p>C：full outer join：</p><p>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择：select * from table1 where Id=1(Id=1为条件语句，根据自己情况自定义）&lt;/p&gt;
&lt;p&gt;插入：insert into table1(field1,field2) values(value1,value2)&lt;/p&gt;
&lt;p&gt;删除：delet
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="SQL的各种基本操作" scheme="https://liuhusen.com/tags/SQL%E7%9A%84%E5%90%84%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
      <category term="MySQL的高级运算符" scheme="https://liuhusen.com/tags/MySQL%E7%9A%84%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="多表查询之左连接，右连接" scheme="https://liuhusen.com/tags/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%B7%A6%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%B3%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL建库建表建索引建视图建主键</title>
    <link href="https://liuhusen.com/2016/05/20/MySQL%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BB%BA%E8%A7%86%E5%9B%BE%E5%BB%BA%E4%B8%BB%E9%94%AE/"/>
    <id>https://liuhusen.com/2016/05/20/MySQL建库建表建索引建视图建主键/</id>
    <published>2016-05-20T05:33:20.000Z</published>
    <updated>2018-10-28T19:13:06.070Z</updated>
    
    <content type="html"><![CDATA[<p>1、说明：创建数据库<br>CREATE DATABASE db1(db1代表数据库表，可自命名)<br>2、说明：删除数据库<br>drop database db1(db1代表数据库表，可自命名)<br>3、说明：备份sql server<br>— 创建 备份数据的 device<br>USE master<br>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’<br>— 开始 备份<br>BACKUP DATABASE pubs TO testBack<br>4、说明：创建新表<br>create table tb1(Id int not null primary key,name varchar,..)(tb1为数据表名，ID为字段，int为数据类型整型，not null为数据是否可为空，Primary Key为主键设置，其中not null,primary key为可选项，字段，数据类型自定义。）<br>根据已有的表创建新表：<br>A：create table tab_new like tab_old (使用旧表创建新表)<br>B：create table tab_new as select col1,col2… from tab_old definition only<br>5、说明：<br>删除新表：drop table tb1<br>6、说明：<br>添加主键：Alter table tabname add primary key(ID)(设置某字段为主键，ID可自由设置，主键数据不可重复）<br>说明：<br>删除主键：Alter table tabname drop primary key(ID)（删除某字段主键）<br>7、说明：<br>创建索引：create [unique] index idxname on tabname(col….)<br>删除索引：drop index idxname<br>注：索引是不可更改的，想更改必须删除重新建。<br>8、说明：<br>创建视图：create view viewname as select statement<br>删除视图：drop view viewname</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、说明：创建数据库&lt;br&gt;CREATE DATABASE db1(db1代表数据库表，可自命名)&lt;br&gt;2、说明：删除数据库&lt;br&gt;drop database db1(db1代表数据库表，可自命名)&lt;br&gt;3、说明：备份sql server&lt;br&gt;— 创建 备份数据的 d
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="建库建表建索引建视图" scheme="https://liuhusen.com/tags/%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BB%BA%E8%A7%86%E5%9B%BE/"/>
    
      <category term="备份数据库" scheme="https://liuhusen.com/tags/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Mysql进行大数据量查询的性能优化</title>
    <link href="https://liuhusen.com/2016/03/26/Mysql%E8%BF%9B%E8%A1%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://liuhusen.com/2016/03/26/Mysql进行大数据量查询的性能优化/</id>
    <published>2016-03-26T10:50:43.000Z</published>
    <updated>2018-10-28T18:34:10.274Z</updated>
    
    <content type="html"><![CDATA[<p>数据库设计方面：</p><p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。<br>             如： select id from t where num is null<br>             可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p><p>3、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，</p><pre><code>那么即使在sex上建了索引也对查询效率起不了作用。</code></pre><p>4、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重</p><pre><code>考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</code></pre><p>5、应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频<br>  繁更新索引数据列，那么需要考虑是否应将该索引建为索引。</p><p>6、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每</p><pre><code>一个字符，而对于数字型而言只需要比较一次就够了。</code></pre><p>7、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>8、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>9、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>10、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先                    create table，然后insert。</p><p>11、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>SQL语句方面：</p><p>1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>2、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描<br>             如： select id from t where num=10 or num=20<br>             可以这样查询： select id from t where num=10 union all select id from t where num=20</p><p>3、in 和 not in 也要慎用，否则会导致全表扫描。<br>             如： select id from t where num in(1,2,3)<br>             对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3</p><p>4、下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’</p><p>5、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。</p><pre><code>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。        如下面语句将进行全表扫描： select id from t where num=@num         可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num</code></pre><p>6、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。<br>             如： select id from t where num/2=100<br>             应改为: select id from t where num=100*2 </p><p>7、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。<br>             如： select id from t where substring(name,1,3)=’abc’   ——name以abc开头的id<br>                     select id from t where datediff(day,createdate,’2005-11-30′)=0  ——‘2005-11-30’生成的id<br>             应改为：<br>                     select id from t where name like ‘abc%’<br>                     select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ </p><p>8、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>9、不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，</p><pre><code>应改成这样： create table #t(„)</code></pre><p>10、很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) </p><pre><code>用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) </code></pre><p>11、任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p><p>12、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>13、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>14、尽量避免大事务操作，提高系统并发能力。</p><p>java方面：</p><p>1、尽可能的少造对象。</p><p>2、合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。</p><p>3、使用jDBC链接数据库操作数据。</p><p>4、控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理。</p><p>5、合理利用内存，有的数据要缓存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库设计方面：&lt;/p&gt;
&lt;p&gt;1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;
&lt;p&gt;2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。&lt;br&gt; 
      
    
    </summary>
    
      <category term="mysql" scheme="https://liuhusen.com/categories/mysql/"/>
    
    
      <category term="大数据量查询" scheme="https://liuhusen.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9F%A5%E8%AF%A2/"/>
    
      <category term="查询优化" scheme="https://liuhusen.com/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    
      <category term="sql语句优化" scheme="https://liuhusen.com/tags/sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>javascript实现锁定网页、密码解锁效果（屏幕保护效果）</title>
    <link href="https://liuhusen.com/2015/12/10/javascript%E5%AE%9E%E7%8E%B0%E9%94%81%E5%AE%9A%E7%BD%91%E9%A1%B5%E3%80%81%E5%AF%86%E7%A0%81%E8%A7%A3%E9%94%81%E6%95%88%E6%9E%9C%EF%BC%88%E5%B1%8F%E5%B9%95%E4%BF%9D%E6%8A%A4%E6%95%88%E6%9E%9C/"/>
    <id>https://liuhusen.com/2015/12/10/javascript实现锁定网页、密码解锁效果（屏幕保护效果/</id>
    <published>2015-12-10T09:20:30.000Z</published>
    <updated>2018-10-31T01:59:56.097Z</updated>
    
    <content type="html"><![CDATA[<p> 功能描述：打开一个网站的网页，过指定时间不动作，就会锁定页面，隐藏内容容器，显示一个容器用于输入密码，输入正确的密码来解锁。锁定后即使用户刷新页面，还是保留原来的状态。如已经锁定的，需要继续锁定，否则显示内容。<br> 示例代码如下，通过document.onmouseover来实现多少分钟没有动作，使用计时器来实现。<br>（此处建议，将下列方法单独提取到一个公共的js中，然后再引用到页面上）</p><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></p><html xmlns="http://www.w3.org/1999/xhtml"><br><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br>    <title>javascript实现系统屏幕保护效果(锁定网页)</title><br></head><br><br><body><br>    <div id="dvContent">内容<br>内容<br>内容<br>内容<br>内容<br>内容</div><br>    <div id="dvPassword" style="display:none">请输入解锁密码：<input type="password" id="txtPwd"><input type="button" value="确定" onclick="check()"></div><br>    <script><br>      if (document.cookie.indexOf(‘lock=1’) != -1) ShowContent(false);<br>      var delay = 10 * 1000,timer;//10s后锁定，修改delay为你需要的时间，单位毫秒<br>      function startTimer() {<br>        clearTimeout(timer);<br>        timer = setTimeout(TimerHandler, delay);<br>      }<br>      function TimerHandler() {<br>        document.cookie = ‘lock=1’;<br>        document.onmousemove = null;//锁定后移除鼠标移动事件<br>        ShowContent(false);<br>      }<br>      function ShowContent(show) {<br>        document.getElementById(‘dvContent’).style.display = show ? ‘block’ : ‘none’;<br>        document.getElementById(‘dvPassword’).style.display = show ? ‘none’ : ‘block’;<br>      }<br>      function check() {<br>        if (document.getElementById(‘txtPwd’).value == ‘123’) {<br>          document.cookie = ‘lock=0’;<br>          ShowContent(true);<br>          startTimer()//重新计时<br>          document.onmousemove = startTimer; //重新绑定鼠标移动事件<br>        }<br>        else alert(‘密码输入错误！！’);<br>      }<br>      window.onload = function () {<br>        document.onmousemove = startTimer;<br>        startTimer();<br>      }<br>    </script><br></body><br></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 功能描述：打开一个网站的网页，过指定时间不动作，就会锁定页面，隐藏内容容器，显示一个容器用于输入密码，输入正确的密码来解锁。锁定后即使用户刷新页面，还是保留原来的状态。如已经锁定的，需要继续锁定，否则显示内容。&lt;br&gt; 示例代码如下，通过document.onmouseo
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="javascript页面效果" scheme="https://liuhusen.com/tags/javascript%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>JS中常用的各类正则表达式以及使用方式收录</title>
    <link href="https://liuhusen.com/2015/11/18/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%90%84%E7%B1%BB%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%94%B6%E5%BD%95/"/>
    <id>https://liuhusen.com/2015/11/18/常用的各类正则表达式以及使用方式收录/</id>
    <published>2015-11-18T04:30:52.000Z</published>
    <updated>2018-10-31T02:48:40.536Z</updated>
    
    <content type="html"><![CDATA[<pre><code>效果上建议查看下面第二部分，如果自定义多变情况，建议使用第一部分；选择合适自己的加入自己的js中</code></pre><p>第一部分： 适用于更适合自己需求的自定义校验方式<br> 特殊字符判断正则表达式<br>        var regEn = /[`~!@#$%^&amp;*()_+&lt;&gt;?:”{},.\/;’[]]/im;<br>        var regCn = /[·！#￥（）：；“”‘、，|《。》？、【】[]]/im;<br>        var re = /([-])\1{1}/;<br> //判断是否包含符合上述的正则表达式（定义一个js内方法校验特殊字符，使用该方法时调用即可）<br>        var isSpecialCharacter = function (characterStr,itemName) {<br>            if(regEn.test(characterStr) || regCn.test(characterStr)) {<br>                crossAPI.tips(itemName+”此处为描述信息，自己随便写！”, 3000);<br>                return true;<br>            }<br>            if(re.test(characterStr))<br>            {<br>                crossAPI.tips(itemName+”此处为描述信息，自己随便写！”, 3000);<br>                return true;<br>            }<br>            return false;<br>        }<br>第二部分： 文本框输入内容控制 更好的效果是input加上onkeyup，onbeforepaste，onblur，onkeydown等事件<br>           使用：建议先定义好需要的正则表达式，再在事件中使用 如：自定义正则表达式.test(“要校验的变量名”)</p><pre><code>整数或者小数：^[0-9]+\.{0,1}[0-9]{0,2}$只能输入数字：&quot;^[0-9]*$&quot;。只能输入n位的数字：&quot;^\d{n}$&quot;。只能输入至少n位的数字：&quot;^\d{n,}$&quot;。只能输入m~n位的数字：。&quot;^\d{m,n}$&quot;只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]{2})?$&quot;。只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]{1,3})?$&quot;。只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。只能输入长度为3的字符：&quot;^.{3}$&quot;。只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。验证用户密码：&quot;^[a-zA-Z]\w{5,17}$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;&apos;,;=?$\&quot;等字符：&quot;[^%&amp;&apos;,;=?$\x22]+&quot;。只能输入汉字：&quot;^[\u4e00-\u9fa5]{0,}$&quot;验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。验证电话号码：&quot;^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。验证身份证号（15位或18位数字）：&quot;^\d{15}|\d{18}$&quot;。验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。匹配中文字符的正则表达式： [\u4e00-\u9fa5]匹配双字节字符(包括汉字在内)：[^\x00-\xff]应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;}匹配空行的正则表达式：\n[\s| ]*\r匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;匹配首尾空格的正则表达式：(^\s*)|(\s*$)匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*匹配网址URL的正则表达式：http://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;效果上建议查看下面第二部分，如果自定义多变情况，建议使用第一部分；
选择合适自己的加入自己的js中
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一部分： 适用于更适合自己需求的自定义校验方式&lt;br&gt; 特殊字符判断正则表达式&lt;br&gt;        var regEn =
      
    
    </summary>
    
      <category term="javascript" scheme="https://liuhusen.com/categories/javascript/"/>
    
    
      <category term="正则表达式" scheme="https://liuhusen.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="输入框的输入限制效果" scheme="https://liuhusen.com/tags/%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E8%BE%93%E5%85%A5%E9%99%90%E5%88%B6%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>this 和super 关键字的区别</title>
    <link href="https://liuhusen.com/2015/11/12/JAVA%E5%9F%BA%E7%A1%80%EF%BC%9Athis%20%E5%92%8Csuper%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liuhusen.com/2015/11/12/JAVA基础：this 和super 关键字的区别/</id>
    <published>2015-11-12T04:33:26.000Z</published>
    <updated>2018-10-30T12:00:30.976Z</updated>
    
    <content type="html"><![CDATA[<pre><code>属性的区别：this访问本类中的属性，如果本类没有此属性则从父类中继续查找。super访问父类中的属性。 方法的区别：this访问本类中的方法，如果本类没有此方法则从父类中继续查找。super访问父类中的方法。 构造的区别：this调用本类构造，必须放在构造方法的首行。super调用父类构造，必须放在子类构造方法首行。 其他区别：this表示当前对象。super不能表示当前对象 1、this. 变量和super.变量     this.变量 调用的当前对象的变量；     super.变量 直接调用的是父类中的变量。     2、this(参数)和super(参数)方法     this(参数) 调用（转发）的是当前类中的构造器；     super(参数) 用于确认要使用父类中的哪一个构造器。 注意点：     1）在对拥有父类的子类进行初始化时，父类的构造方法也会执行，且优先于子类的构造函数执行；因为每一个子类的构造函数中的第一行都有一条默认的隐式语句super();     2）this() 和super()都只能写在构造函数的第一行；     3）this() 和super() 不能存在于同一个构造函数中。第一，this()和super()都必须写在构造函数的第一行；第二，this()语句调用的是当前类的另一个构造函数而这个另一个构造函数中必然有一个父类的构造器，再使用super()又调用一次父类的构造器， 就相当于调用了两次父类的构造器，编译器不会通过；     4）this和super不能用于static修饰的变量，方法，代码块；因为this和super都是指的是对象（实例）。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;属性的区别：this访问本类中的属性，如果本类没有此属性则从父类中继续查找。super访问父类中的属性。 
方法的区别：this访问本类中的方法，如果本类没有此方法则从父类中继续查找。super访问父类中的方法。 
构造的区别：this调用本类构造，必须放在
      
    
    </summary>
    
      <category term="JAVA基础" scheme="https://liuhusen.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="https://liuhusen.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java的四个基本特性（抽象、封装、继承，多态）</title>
    <link href="https://liuhusen.com/2015/10/08/Java%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%88%E6%8A%BD%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81%EF%BC%89/"/>
    <id>https://liuhusen.com/2015/10/08/Java的四个基本特性（抽象、封装、继承，多态）/</id>
    <published>2015-10-08T05:01:30.000Z</published>
    <updated>2018-11-14T08:13:16.754Z</updated>
    
    <content type="html"><![CDATA[<p>   Java的四个基本特性（抽象、封装、继承，多态）：</p><p>   –抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。<br>     抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。</p><p>  –封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信<br>          的进行封装隐藏。<br>    封装分为属性的封装和方法的封装。</p><p>  –继承：是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于<br>          抽取多类事物的共性。</p><p>  –多态：允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   Java的四个基本特性（抽象、封装、继承，多态）：&lt;/p&gt;
&lt;p&gt;   –抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。&lt;br&gt;     抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的
      
    
    </summary>
    
      <category term="java基础" scheme="https://liuhusen.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="https://liuhusen.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试常问" scheme="https://liuhusen.com/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>什么是泛型、为什么要使用以及泛型擦除</title>
    <link href="https://liuhusen.com/2015/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <id>https://liuhusen.com/2015/10/08/什么是泛型、为什么要使用以及泛型擦除/</id>
    <published>2015-10-08T05:01:30.000Z</published>
    <updated>2018-11-14T08:31:35.285Z</updated>
    
    <content type="html"><![CDATA[<p>   什么是泛型、为什么要使用以及泛型擦除：</p><p>   泛型，即“参数化类型”。<br>   创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。<br>   Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦<br>   除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java<br>   代码直接转换成普通java字节码。<br>   类型擦除的主要过程如下：<br>       1）.将所有的泛型参数用其<br>       2）.移除所有的类型参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   什么是泛型、为什么要使用以及泛型擦除：&lt;/p&gt;
&lt;p&gt;   泛型，即“参数化类型”。&lt;br&gt;   创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。&lt;br&gt;   Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理
      
    
    </summary>
    
      <category term="java基础" scheme="https://liuhusen.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="https://liuhusen.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试常问" scheme="https://liuhusen.com/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>构造器Constructor是否可被override</title>
    <link href="https://liuhusen.com/2015/10/08/%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverride/"/>
    <id>https://liuhusen.com/2015/10/08/构造器Constructor是否可被override/</id>
    <published>2015-10-08T05:01:30.000Z</published>
    <updated>2018-11-14T08:17:12.433Z</updated>
    
    <content type="html"><![CDATA[<p>   构造器Constructor是否可被override：</p><p>   构造器不能被重写，不能用static修饰构造器，只能用public<br>   private protected这三个权限修饰符，且不能有返回语句。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   构造器Constructor是否可被override：&lt;/p&gt;
&lt;p&gt;   构造器不能被重写，不能用static修饰构造器，只能用public&lt;br&gt;   private protected这三个权限修饰符，且不能有返回语句。&lt;/p&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="https://liuhusen.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="https://liuhusen.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试常问" scheme="https://liuhusen.com/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>hashCode和equals方法的关系</title>
    <link href="https://liuhusen.com/2015/10/08/hashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://liuhusen.com/2015/10/08/hashCode和equals方法的关系/</id>
    <published>2015-10-08T05:01:30.000Z</published>
    <updated>2018-11-14T08:25:34.893Z</updated>
    
    <content type="html"><![CDATA[<p>   hashCode和equals方法的关系：</p><p>   –equals相等，hashcode必相等；hashcode相等，equals可能不相等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   hashCode和equals方法的关系：&lt;/p&gt;
&lt;p&gt;   –equals相等，hashcode必相等；hashcode相等，equals可能不相等&lt;/p&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="https://liuhusen.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="https://liuhusen.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试常问" scheme="https://liuhusen.com/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>自动装箱与拆箱</title>
    <link href="https://liuhusen.com/2015/10/08/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <id>https://liuhusen.com/2015/10/08/自动装箱与拆箱/</id>
    <published>2015-10-08T05:01:30.000Z</published>
    <updated>2018-11-14T08:29:28.246Z</updated>
    
    <content type="html"><![CDATA[<p>   自动装箱与拆箱：</p><p>   装箱：将基本类型用它们对应的引用类型包装起来；<br>   拆箱：将包装类型转换为基本数据类型；<br>   Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完<br>   成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   自动装箱与拆箱：&lt;/p&gt;
&lt;p&gt;   装箱：将基本类型用它们对应的引用类型包装起来；&lt;br&gt;   拆箱：将包装类型转换为基本数据类型；&lt;br&gt;   Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完&lt;br&gt;   成，编译
      
    
    </summary>
    
      <category term="java基础" scheme="https://liuhusen.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="https://liuhusen.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试常问" scheme="https://liuhusen.com/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"/>
    
  </entry>
  
</feed>
